# AGENT ARCHITECTURE & DESIGN CONTRACT

> **This file is for AI agents ONLY.**
> It defines non-negotiable architectural, security, and design constraints.
>
> Any code change that violates this file is considered a defect,
> even if functionality appears correct.

---

## 0. AGENT PRE-FLIGHT CHECKLIST

**MANDATORY: Read this section before writing any code.**

Before implementing any change, you MUST confirm:

- [ ] I identified which sections of this document my change affects
- [ ] I confirmed OS impact (Windows / Linux / macOS) and runtime detection needs
- [ ] I identified SSOT modules involved (`core/version.py`, `core/constants.py`, etc.)
- [ ] I identified required test additions (unit / integration / E2E / verification)
- [ ] I confirmed which documentation files require updates (README.md FIRST)
- [ ] I confirmed no security invariants are weakened (Section 7)
- [ ] I confirmed no OS-independence rules are violated (Section 2)
- [ ] I confirmed path handling uses `pathlib.Path` only (Section 5)

**If you cannot confirm all items: STOP. Clarify before proceeding.**

---

## 1. PURPOSE OF THE SOFTWARE

SmartDrive / KeyDrive is a security-critical system that:
- Manages VeraCrypt-encrypted volumes
- Integrates hardware-backed authentication (YubiKey / GPG)
- Provides deterministic, auditable recovery
- Prioritizes *correctness, predictability, and user trust* over convenience

This is **NOT**:
- a general-purpose encryption tool
- a UI-first application
- a system that tolerates silent failure

---

## 2. OS INDEPENDENCE CONTRACT (NON-NEGOTIABLE)

**Cross-platform first: Windows, Linux, macOS.**

### 2.1 Core Rules

| Rule | Requirement |
|------|-------------|
| **Multi-Platform Support** | ALL features MUST work on Windows, Linux, and macOS unless technically impossible |
| **No Platform Assumptions** | NEVER assume OS from environment; use explicit detection |
| **Runtime Detection** | GUI availability, CLI capabilities, clipboard support, command syntax MUST be detected at runtime |
| **Path Portability** | Use `pathlib.Path` exclusively (see Section 5) |
| **Command Isolation** | OS-specific commands MUST live in `core/platform.py`, selected at runtime |
| **Graceful Fallbacks** | Unavailable CLI features fall back to documented GUI guidance |

### 2.2 REQUIRED Detection Points

MUST be detected at runtime, NEVER assumed:
- VeraCrypt GUI availability (display server, Windows GUI subsystem)
- VeraCrypt CLI version and supported flags
- Clipboard support (availability, security)
- Command syntax (Windows `/flag` vs Unix `--flag`)
- Drive letter concept (Windows-only)

### 2.3 Common Violations (FORBIDDEN)

- Hardcoded Windows-only paths or commands without Unix equivalents
- Assuming drive letters exist
- Assuming clipboard is available without runtime check
- Assuming GUI can be launched without checking display environment
- Using shell-specific syntax without proper escaping
- Platform-dependent security guarantees

**Violation of OS independence is an architectural defect.**

---

## 3. CORE DESIGN PRINCIPLES

### 3.1 Boring Reliability
- Failure MUST be loud, explicit, and explainable
- Silent fallback is FORBIDDEN
- Success messages MUST reflect actual system state

### 3.2 Determinism
- Same inputs MUST always produce same outcomes
- No environment-dependent security downgrade
- No hidden behavior changes

### 3.3 Trust Preservation
- If the user explicitly requests a security feature (e.g. recovery), failure MUST abort, not warn
- NEVER claim "SETUP COMPLETE" if critical steps failed

### 3.4 Human-in-the-loop Honesty
- Manual steps (VeraCrypt GUI) are acknowledged, not hidden
- Verification failures default to ABORT, not CONTINUE
- Overrides REQUIRE explicit, informed consent

---

## 3. SINGLE SOURCE OF TRUTH (SSOT)

### 3.1 Rule
Every shared value MUST be defined exactly once.

Duplicating a constant, state string, config key, or version number
is a **violation** of this contract.

### 3.2 Authoritative Modules

| Category | Module | Contents |
|----------|--------|----------|
| Version | `core/version.py` | `VERSION`, build identifiers |
| Constants | `core/constants.py` | `ConfigKeys`, `UserInputs`, `CryptoParams`, `FileNames`, `Branding`, `Defaults`, `CLIOperations`, `ConsoleStyle`, `VeraCryptFlags` |
| Paths | `core/paths.py` | ALL filesystem paths as `Path` objects via `Paths` class (including `static_file()`, `icon_mounted()`, etc.) |
| Limits / Policy | `core/limits.py` | `Limits` class: timeouts, retries, thresholds |
| States / Modes | `core/modes.py` | `SecurityMode`, `RecoveryOutcome`, `SetupState` enums |
| Platform | `core/platform.py` | `is_admin()`, `get_platform()`, platform-specific detection |

### 3.3 SSOT Rules
- No globals outside `core/*`
- No inline literals for shared concepts
- No star imports (`from module import *`)
- No circular imports
- Fallbacks inside `except ImportError:` blocks are permitted for standalone operation

### 3.4 Constant Categories

| Class | Purpose | Example Usage |
|-------|---------|---------------|
| `ConfigKeys` | JSON config dictionary keys | `cfg.get(ConfigKeys.VOLUME_PATH)` |
| `UserInputs` | Fixed confirmation strings | `if confirm == UserInputs.YES:` |
| `SecurityMode` | Authentication mode enum | `SecurityMode.GPG_PW_ONLY.value` |
| `Limits` | Numeric constraints | `timeout=Limits.GPG_CARD_STATUS_TIMEOUT` |

---

## 4. PATH HANDLING (ABSOLUTE RULE)

### 4.1 Zero String Paths
- No hardcoded paths (`"/home/user"`, `"C:\\Program Files"`)
- No string concatenation for paths (`dir + "/" + file`)
- No f-strings for paths (`f"{base}/{name}"`)
- No manual slash normalization

### 4.2 Required Practice
- Use `pathlib.Path` everywhere internally
- Convert `Path → str` ONLY at I/O boundaries:
  - subprocess calls: `str(path)`
  - JSON serialization
  - User-facing output

### 4.3 Canonical Paths
All filesystem locations are defined in:
- `core/paths.py` via the `Paths` class

No other module may construct filesystem paths from scratch.

### 4.4 Permitted Patterns
```python
# ALLOWED
from core.paths import Paths
config_file = Paths.config_file()
volume = Path(user_input)  # User-provided paths

# FORBIDDEN
config_file = "/path/to/config.json"
volume = f"{drive}:/container.vc"
```

---

## 5. RECOVERY SYSTEM GUARANTEES

### 5.1 Core Invariant
**Recovery NEVER mounts with a recovery password.**

Recovery ALWAYS reconstructs original credentials via encrypted container.
Header backup is used ONLY for corruption recovery.

### 5.2 One-Time Semantics
- Recovery is one-time AFTER SUCCESS
- Failed attempts must preserve recovery capability
- State machine:
  ```
  enabled → consuming → used
  ```

### 5.3 Hard Guarantees
- No recovery password mounts
- No silent crypto downgrade
- No recovery if prerequisites fail
- Mandatory rekey after successful recovery

### 5.4 Volume Binding
- Recovery kit is cryptographically bound to:
  - volume path
  - volume identity hash
- Wrong-volume recovery MUST fail loudly

---

## 6. FAILURE CLASSIFICATION

All recovery failures MUST map to exactly one outcome in `RecoveryOutcome`:

| Outcome | Meaning | Retry Safe |
|---------|---------|------------|
| `SUCCESS` | Operation completed | N/A |
| `TRANSIENT_FAILURE` | Temporary issue | Yes |
| `PERMANENT_FAILURE` | Unrecoverable | No |
| `ENVIRONMENT_FAILURE` | Missing dependencies | Maybe |
| `USER_ABORT` | User cancelled | Yes |

**No ambiguous failures allowed.**

---

## 7. SECURITY INVARIANTS

AI agents MUST NOT:
- Change cryptographic primitives without explicit authorization
- Add fallback crypto without explicit opt-in
- Print secrets to terminal by default
- Bypass YubiKey requirements in GPG modes
- Continue setup after P0 (critical) failures
- Reduce security based on environment detection

### 7.1 Security Modes (Immutable Definitions)

| Mode | Value | Description |
|------|-------|-------------|
| `PW_ONLY` | `"pw_only"` | Password only, no keyfile |
| `PW_KEYFILE` | `"pw_keyfile"` | Password + plain keyfile |
| `PW_GPG_KEYFILE` | `"pw_gpg_keyfile"` | Password + GPG-encrypted keyfile |
| `GPG_PW_ONLY` | `"gpg_pw_only"` | GPG-derived password (YubiKey) |

These string values are defined in `core/modes.py` and MUST NOT be duplicated elsewhere.

---

## 8. USER INTERACTION CONTRACT

### 8.1 Confirmation Requirements
- Destructive actions require explicit confirmation
- Confirmation strings are defined in `UserInputs` class:
  - `YES`, `ERASE`, `RECOVER`, `REKEY`, `ACCEPT_UNVERIFIED`

### 8.2 Platform Warnings
- Windows-specific security warnings MUST be runtime-blocking
- Password exposure risks require explicit consent

### 8.3 Secret Handling
- Clipboard-first handling for secrets when available
- Auto-clear clipboard after timeout (`Limits.CLIPBOARD_TIMEOUT`)

---

## 9. TIMEOUT AND RETRY POLICY

All timeouts and retry limits are defined in `core/limits.py`.

### 9.1 Standard Timeouts

| Constant | Value | Use Case |
|----------|-------|----------|
| `PROCESS_CHECK_TIMEOUT` | 5s | Quick process checks (pgrep, tasklist) |
| `GPG_CARD_STATUS_TIMEOUT` | 10s | GPG card status, version checks |
| `GPG_DECRYPT_TIMEOUT` | 30s | GPG decryption operations |
| `VERACRYPT_MOUNT_TIMEOUT` | 60s | VeraCrypt mount operations |
| `VERACRYPT_FORMAT_TIMEOUT` | 300s | Volume creation |

### 9.2 Retry Limits

| Constant | Value | Use Case |
|----------|-------|----------|
| `YUBIKEY_MAX_ATTEMPTS` | 3 | YubiKey PIN attempts |
| `MOUNT_MAX_ATTEMPTS` | 3 | Mount retry limit |

---

## 10. AUDITABILITY

- All recovery attempts are logged
- Logs contain metadata only (no secrets)
- Logs are append-only
- Audit function: `audit_log(event, outcome, metadata)`

---

## 11. CHANGE MANAGEMENT RULES (FOR AI AGENTS)

### 11.1 Before Implementing Changes
1. Identify which section(s) of this file are affected
2. If a change violates a rule → **STOP and fail explicitly**
3. If a new principle is introduced:
   - Update this file FIRST
   - Then implement code changes

### 11.2 When Adding New Constants
1. Determine the appropriate `core/` module
2. Add the constant to that module
3. Import and use the constant (never duplicate)
4. If you introduce a fallback definition for any `ConfigKeys` (or other
   SSOT class) inside an `except ImportError:` fallback in any script, you
   MUST also add that exact key to the authoritative SSOT module
   (`core/constants.py`) before committing. Failing to do so creates
   divergent sources of truth and is a contract violation.

   - Rationale: fallbacks are tolerated only to allow standalone execution
     during development or packaging; the canonical repository must always
     contain the authoritative definitions.
   - Enforcement: CI and agents will treat missing SSOT entries as defects
     and block merges until the SSOT is updated.

### 11.3 When Modifying Security Behavior
1. Check Section 7 (Security Invariants)
2. If the change reduces security → **ABORT**
3. Document the security implications

### 11.4 Documentation Synchronization (Mandatory)
1. The `README.md` and all its derived or variant documentation files
   (including but not limited to `GUI_README.md`, `RECOVERY_TECHNICAL.md`,
   and any other user-facing or developer-facing READMEs) MUST be updated
   to accurately reflect any code or behavioral change made in this
   repository.
2. This update is non-optional: any change to the codebase, configuration,
   behavior, or user workflow requires a corresponding, human-readable
   documentation update. Failure to update documentation is considered an
   architectural defect.
3. Agents must follow this sequence when a change affects documentation:
   - Update `AGENT_ARCHITECTURE.md` first if the change affects architecture
     or agent obligations (already a requirement in 11.1).
   - Update `README.md` as the canonical top-level summary of changes.
   - Propagate relevant updates to derived documents (`GUI_README.md`,
     `RECOVERY_TECHNICAL.md`, etc.) so that operator-facing instructions
     and technical references remain consistent.
4. Enforcement: CI and agents will treat missing or stale documentation as a
   defect; enforcement scripts and reviewers must block merges where the
   documentation was not updated to match the change.

---

## 12. ENFORCEMENT

The following scripts MUST pass before any commit:

```bash
python scripts/check_no_string_paths.py
python scripts/check_single_source_of_truth.py
```

### 12.1 What They Check

| Script | Validates |
|--------|-----------|
| `check_no_string_paths.py` | No hardcoded filesystem paths |
| `check_single_source_of_truth.py` | No duplicated constants, proper imports |

### 12.2 Failure Response
Failure of either script indicates **architectural regression**.
- Do not bypass or disable these checks
- Fix the violation before proceeding

---

## 13. DIRECTORY STRUCTURE CONTRACT

```
core/                    # SSOT modules (authoritative)
├── __init__.py
├── version.py          # VERSION
├── constants.py        # ConfigKeys, UserInputs, CryptoParams, etc.
├── paths.py            # Paths class
├── limits.py           # Limits class
└── modes.py            # SecurityMode, RecoveryOutcome enums

scripts/                 # Implementation scripts
├── check_no_string_paths.py        # Enforcement
├── check_single_source_of_truth.py # Enforcement
├── mount.py
├── unmount.py
├── setup.py
├── recovery.py
├── rekey.py
└── ...

reference_scripts/       # EXCLUDED from checks (legacy reference)
helper/                  # EXCLUDED from checks (utilities)
```

---

## 14. IMPORT PATTERNS

### 14.1 Required Pattern
```python
# At top of script, after standard library imports
from core.version import VERSION
from core.paths import Paths
from core.constants import ConfigKeys, UserInputs
from core.limits import Limits
from core.modes import SecurityMode
```

### 14.2 Fallback Pattern (Standalone Operation)
```python
try:
    from core.constants import ConfigKeys
except ImportError:
    # Fallback for standalone operation - ONLY in except block
    class ConfigKeys:
        VOLUME_PATH = "volume_path"
```

---

## 15. FINAL DIRECTIVE TO AI AGENTS

If you are unsure whether a change is allowed:
- **Assume it is NOT**
- Abort and ask for clarification

When implementing changes:
1. Run enforcement scripts first to establish baseline
2. Make changes
3. Run enforcement scripts again
4. If scripts fail → fix violations before proceeding

**This file is binding.**

---

## 16. TESTING, CI, AND VALIDATION (FOR AI AGENTS)

This section defines the mandatory, repeatable test and CI actions an AI agent must perform and keep up-to-date when implementing code changes.
All items below are normative rules (not suggestions).

16.1 Required Test Locations and Naming
- Unit tests: `tests/unit/` with filenames `test_*.py`.
- Integration tests: `tests/integration/` with filenames `test_*.py`.
- End-to-end or system tests: `tests/e2e/` as appropriate.
- Test helper modules: `tests/helpers/` only.

16.2 Required Test Tools and Commands
- Local reproducible environment setup (Windows PowerShell example):
```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install -r requirements.txt
pip install -r requirements-dev.txt  # if present
```
- Run unit tests (fail on any failing test):
```powershell
python -m pytest tests/unit -q --maxfail=1
```
- Run integration tests (only after unit tests pass):
```powershell
python -m pytest tests/integration -q
```
- Run static checks and formatters (required):
```powershell
python -m pip install black isort flake8
black .
isort .
flake8 .
```
- Run enforcement scripts (always):
```powershell
python scripts/check_no_string_paths.py
python scripts/check_single_source_of_truth.py
```

16.3 CI and Pre-Commit Requirements
- Every CI run must execute, in order:
  1. `python -m pytest tests/unit -q --maxfail=1`
  2. `python -m pytest tests/integration -q` (if integration tests exist)
  3. `python scripts/check_no_string_paths.py`
  4. `python scripts/check_single_source_of_truth.py`
  5. `black --check .` and `isort --check-only .`
- Agents must ensure GitHub Actions or equivalent CI workflows run the above commands.
- Agents must not merge or commit code that fails CI.

16.4 Test Coverage and Acceptance
- New features require unit tests covering edge cases and failure modes.
- Security-sensitive code (cryptography, recovery, mounting) requires tests for failure semantics and invariant preservation.
- Acceptance criteria for a change:
  - All unit tests pass
  - Enforcement scripts pass
  - Lint/format checks pass

16.5 Agent Obligations Regarding Tests
- When changing behavior, agents MUST:
  1. Update `AGENT_ARCHITECTURE.md` first if the change affects architecture, invariants, or testing requirements.
  2. Add or update unit/integration tests to cover the change.
  3. Run all tests and enforcement scripts locally before committing.
  4. Include a brief test plan in the commit message when tests are added/updated.

16.6 Failure Handling for Tests
- If a test fails after a change, the agent MUST NOT proceed. The agent must either:
  - Fix the code so tests pass while preserving architecture rules, OR
  - Revert the change and open an explicit MR/issue describing the incompatibility.

16.7 Minimal Test Templates
- Agents must create test templates when adding new modules. A minimal unit test example:
```python
def test_my_feature_basic():
    # Arrange
    # Act
    # Assert
    assert True
```

---

## 17. FILE STRUCTURE & OBSOLETE FILE POLICY

This section defines binding rules for maintaining repository structure integrity and handling file lifecycle changes. Agents MUST follow these rules to prevent accidental deletion of code and maintain architectural clarity.

### 17.1 Canonical Repo Tree

**Canonical Repo Tree (must be updated with every structural change)**

```text
VeraCrypt_Yubikey_2FA/
├── .smartdrive/                    # CANONICAL RUNTIME TREE (deployed 1:1 to drive)
│   ├── core/                       # SSOT modules (authoritative, never obsolete)
│   │   ├── __init__.py
│   │   ├── version.py              # VERSION constant
│   │   ├── constants.py            # ConfigKeys, UserInputs, CryptoParams, CLIOperations
│   │   ├── paths.py                # Paths class
│   │   ├── limits.py               # Limits class (timeouts, retries)
│   │   ├── modes.py                # SecurityMode, RecoveryOutcome enums
│   │   └── platform.py             # is_admin(), platform detection (NEW)
│   │
│   └── scripts/                    # Runtime implementation scripts
│       ├── setup.py                # Setup wizard (main entry point)
│       ├── mount.py                # Mount volume
│       ├── unmount.py              # Unmount volume
│       ├── recovery.py             # Recovery kit generation/usage
│       ├── recovery_container.py   # Recovery crypto container
│       ├── veracrypt_cli.py        # VeraCrypt CLI wrapper
│       ├── crypto_utils.py         # Cryptographic utilities
│       ├── rekey.py                # Password/key rotation
│       ├── keyfile.py              # Keyfile management
│       ├── smartdrive.py           # CLI launcher (unified menu)
│       ├── gui_launcher.py         # GUI launcher
│       ├── gui.py                  # GUI implementation
│       ├── gui_i18n.py             # GUI internationalization
│       ├── deploy.py               # Deployment tool
│       ├── update.py               # Update mechanism
│       └── version.py              # Version re-export
│
├── scripts/                        # DEV-ONLY wrappers (NOT deployed)
│   ├── setup.py                    # -> .smartdrive/scripts/setup.py
│   ├── gui.py                      # -> .smartdrive/scripts/gui.py
│   ├── mount.py                    # -> .smartdrive/scripts/mount.py
│   ├── unmount.py                  # -> .smartdrive/scripts/unmount.py
│   ├── recovery.py                 # -> .smartdrive/scripts/recovery.py
│   ├── smartdrive.py               # -> .smartdrive/scripts/smartdrive.py
│   ├── deploy.py                   # -> .smartdrive/scripts/deploy.py
│   ├── check_no_string_paths.py    # Enforcement: path purity
│   └── check_single_source_of_truth.py  # Enforcement: SSOT compliance
│
├── tests/                          # Test suite
│   ├── unit/
│   └── integration/
│
├── docs/                           # Technical documentation
│   └── RECOVERY_TECHNICAL.md       # Recovery system deep-dive
│
├── static/                         # GUI assets (icons, images)
│
├── keys/                           # Encrypted keyfile storage
│   └── keyfile.vc.gpg
│
├── reference_scripts/              # Legacy reference code (excluded from checks)
│
├── helper/                         # Development utilities (excluded from checks)
│
├── obsolete/                       # Obsolete files (date-organized)
│   └── YYYY-MM-DD/
│       ├── <moved_file>
│       └── WHY.md
│
├── AGENT_ARCHITECTURE.md           # This file (binding contract)
├── README.md                       # User-facing documentation
├── GUI_README.md                   # GUI-specific documentation
├── requirements.txt                # Python dependencies
├── constants.py                    # Legacy constants (being phased out)
├── variables.py                    # Branding customization
├── KeyDrive.bat                    # Windows launcher
├── KeyDriveGUI.bat                 # Windows GUI launcher
├── keydrive.sh                     # Unix launcher
├── KeyDriveGUI.spec                # PyInstaller spec for GUI
└── .gitignore

```

**Update Policy:**
- Agents MUST update this tree whenever:
  - Adding a new file to the repository
  - Moving a file to `obsolete/`
  - Renaming a file or directory
  - Creating a new directory
  - Changing file purpose/classification (e.g., enforcement → obsolete)

### 17.2 Obsolete File Workflow

When an agent determines a file is no longer needed, the following workflow is **mandatory**:

#### 17.2.1 Pre-Obsolescence Verification (REQUIRED)

Before marking any file as obsolete, agents MUST:

1. **Run repository-wide reference scan** to verify the file is truly unused:
   - `grep -r "import <module_name>" .` (or equivalent)
   - Check `scripts/check_single_source_of_truth.py` patterns
   - Search for CLI entrypoint references
   - Check deployment scripts (`setup.py`, `deploy_scripts_extended`)
   - Search documentation for references (`README.md`, `GUI_README.md`, `docs/*`)

2. **Verify no duplicate implementations exist**:
   - Ensure the file's functionality is not split across multiple locations
   - Confirm replacement file(s) are identified

3. **Check SSOT module protection**:
   - Files in `core/*` MUST NOT be moved to obsolete
   - Enforcement scripts MUST NOT be moved to obsolete
   - Recovery system files MUST NOT be moved to obsolete without explicit architectural approval

#### 17.2.2 Move to Obsolete (Standard Procedure)

If verification passes, follow this procedure:

1. **Create date-stamped obsolete directory**:
   ```
   obsolete/YYYY-MM-DD/
   ```
   Use the current date in ISO 8601 format (e.g., `2025-12-15`).

2. **Move the file** (preserve relative path structure if needed):
   ```
   git mv <original_path> obsolete/YYYY-MM-DD/<original_filename>
   ```

3. **Create WHY.md** in the same date folder:
   ```markdown
   # Obsolescence Record: YYYY-MM-DD
   
   ## File: <original_filename>
   **Original Path:** `<full_original_path>`
   **Moved Date:** YYYY-MM-DD
   **Moved By:** [Agent/Human identifier]
   
   ## Reason for Obsolescence
   [Clear explanation: redundant, superseded, refactored, etc.]
   
   ## Replacement
   **Replaced By:** `<new_file_path>` (if applicable)
   **Migration Notes:** [How functionality was preserved]
   
   ## Verification Steps
   To confirm this file is safe to delete permanently:
   1. [Step 1: e.g., run enforcement scripts]
   2. [Step 2: e.g., test setup wizard end-to-end]
   3. [Step 3: e.g., verify no import errors]
   4. [Step 4: e.g., check deployment works on clean drive]
   
   ## Safe to Delete After
   [Date or milestone, e.g., "2026-01-15" or "After v2.0 release"]
   ```

4. **Update imports and references**:
   - Remove imports of the obsolete file
   - Update deployment scripts if file was deployed
   - Update enforcement script exclusions if needed
   - Verify code runs without the file

5. **Update canonical tree** in this document (Section 17.1).

6. **Commit with descriptive message**:
   ```
   Move <filename> to obsolete: <brief_reason>
   
   - Moved to obsolete/YYYY-MM-DD/
   - Created WHY.md documenting obsolescence
   - Updated references in [list files]
   - Updated canonical tree in AGENT_ARCHITECTURE.md
   ```

#### 17.2.3 Build Artifacts Exception

Auto-generated build artifacts MAY be deleted without moving to obsolete IF:
- The file is in a documented build/output directory (`dist/`, `build/`, `__pycache__/`)
- The file is ignored by `.gitignore`
- The file is NOT referenced by runtime code
- The file can be regenerated by documented build commands

Examples: `*.pyc`, `dist/KeyDriveGUI.exe`, `__pycache__/*`

### 17.3 Verification Checklist

Before finalizing any file move to obsolete, agents MUST confirm:

- [ ] Repository-wide reference scan completed (no imports, no CLI refs, no docs refs)
- [ ] Replacement file(s) identified and documented in WHY.md
- [ ] Code runs without the obsolete file (tests pass, enforcement scripts pass)
- [ ] Deployment still works (if file was deployed)
- [ ] No SSOT module protection violated
- [ ] Canonical tree updated in AGENT_ARCHITECTURE.md
- [ ] WHY.md created with clear verification steps
- [ ] No duplicate live implementations exist

### 17.4 Prohibited Actions

Agents MUST NOT:

1. **Permanently delete source files by default**
   - Moving to `obsolete/` is the standard procedure
   - Deletion requires explicit user confirmation after testing period

2. **Move files to obsolete without updating the canonical tree**
   - The tree in Section 17.1 MUST reflect current repository state

3. **Move SSOT modules to obsolete**
   - Files in `core/` are architectural foundations and cannot be obsoleted without redesign
   - This includes: `version.py`, `constants.py`, `paths.py`, `limits.py`, `modes.py`

4. **Move enforcement scripts to obsolete**
   - `check_no_string_paths.py` and `check_single_source_of_truth.py` are binding enforcement
   - Enforcement changes require architectural discussion

5. **Move files without creating WHY.md**
   - Documentation is mandatory for future auditing

6. **Skip the verification checklist**
   - All items in Section 17.3 are mandatory

7. **Leave "half-dead" files**
   - If a file is moved to obsolete, ALL references must be removed
   - No orphaned imports, no dead deployment entries

### 17.5 Obsolete File Review and Cleanup

**Review Schedule:**
- Obsolete files older than 90 days MAY be reviewed for permanent deletion
- Review requires:
  - Verification steps in WHY.md completed successfully
  - No issues reported related to the obsolete file
  - User/maintainer approval

**Permanent Deletion Criteria:**
- All verification steps passed
- Sufficient testing period elapsed (minimum 90 days)
- No rollback scenarios require the file
- User explicitly confirms deletion

---

*Last updated: 2025-12-15*
*Enforcement status: Both checks PASSING*
